# -*- coding: utf-8 -*-
"""Recommendations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DbcI8djpTffSySde6CucIeY3h0mzyD1p
"""

import pandas as pd
import numpy as np
import os
import sys
import logging
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics.pairwise import euclidean_distances
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE

def load_menu_data(file_path: str) -> pd.DataFrame:
  if not os.path.exists(file_path):
   logging.error(f"File not found: {file_path}")
   raise FileNotFoundError(f"The file {file_path} does not exist.")
  logging.info(f"Loading file: {file_path}")
  return pd.read_excel(file_path)

def process_data(df: pd.DataFrame) -> np.hstack:
  df['flavour_weight'] = df['flavour_weight'].apply(eval)
  flavor_df = pd.json_normalize(df['flavour_weight'])
  scaler = StandardScaler()
  scaled_flavors = scaler.fit_transform(flavor_df)
  tfidf = TfidfVectorizer(stop_words='english')
  ingredient_tfidf = tfidf.fit_transform(df['ingredients'])
  combined_features = np.hstack([scaled_flavors, ingredient_tfidf.toarray()])
  return combined_features


def recommend_cosine_sim(menu, cuisine, taste_profile, combined_features, top_n=5):
  taste_profile = taste_profile.strip().lower()
  taste_profile_dic = {taste_profile: 1.0}
  valid_flavors = {"sweet", "salty", "sour", "bitter", "umami"}
  flavor_profile = {flavor: 0.0 for flavor in valid_flavors}
  for key in taste_profile_dic:
        if key in flavor_profile:
            flavor_profile[key] = taste_profile_dic[key]
        else:
            raise ValueError(f"Invalid flavor: {key}. Must be one of {list(valid_flavors)}")
  filtered_df = menu[menu['cuisine'].str.strip().str.lower() == cuisine.strip().lower()].copy()
  filtered_df = filtered_df[filtered_df['dominant_flavor'].str.strip().str.lower() == taste_profile].copy()
  if filtered_df.empty:
        return f"No menu items found for the cuisine {cuisine} and flavor {taste_profile}."
  flavor_profiles = np.array([list(flavor.values()) if isinstance(flavor, dict) else [0] * len(flavor_profile) for flavor in filtered_df['flavour_weight']])
  input_profile = np.array(list(flavor_profile.values())).reshape(1, -1)
  cosine_sim = cosine_similarity(input_profile, flavor_profiles).flatten()
  cosine_dist = 1 - cosine_sim
  sim_scores = np.argsort(cosine_dist)[:top_n]
  recommendations = filtered_df.iloc[sim_scores][['menu_item_id', 'menu_item', 'cuisine', 'ingredients', 'dominant_flavor']]
  recommendations['cosine distance'] = cosine_dist[sim_scores]
  return recommendations

def get_restaurant_name(name):
  name = name[:-3]
  name = name.replace("_", " ")
  name = name.title()
  return name

def main(path, cuisine_input, flavor_input, container):
  try:
        menu = load_menu_data(path) #Loads excel into df

        cuisine = cuisine_input
        taste_profile = flavor_input
        combined_features = process_data(menu)
        n = 5
        visualize = False
        if (type(recommend_cosine_sim(menu, cuisine, taste_profile, combined_features, n)) == str):
          container.write("No menu items found for your choice of cuisine (" + cuisine_input + ") and flavor (" + flavor_input + ").")
        else:
          container.write("Based on your choice of cuisine (" + cuisine_input + ") and flavor (" + flavor_input + "), we recommend the following menu items:")
          res_cos = pd.DataFrame(recommend_cosine_sim(menu, cuisine, taste_profile, combined_features, n))
          num_rows = res_cos.shape[0]
          for i in range(num_rows):
            container.write("Choice " + str(i+1) + ": " + res_cos['menu_item'].iloc[i] + " at " + get_restaurant_name(res_cos['menu_item_id'].iloc[i]))
          container.subheader("The full dataframe")
          container.table(res_cos[['cuisine','menu_item','ingredients','dominant_flavor','cosine distance']])

  except Exception as e:
      logging.error(f"An error occurred: {e}")
      st.write(logging.error(f"An error occurred: {e}"))
      raise